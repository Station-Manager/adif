package adif

import (
	"bytes"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"time"
)

func (r *Record) String() string {
	return parseToAdifString(r)
}

func (h *HeaderSection) String() string {
	ts := h.CreatedTimestamp
	if ts == emptyString {
		ts = time.Now().UTC().Format("20060102150405")
	}
	ver := h.ADIFVer
	if ver == emptyString {
		ver = Version
	}
	pid := h.ProgramID
	if pid == emptyString {
		pid = "7QSM"
	}
	pver := h.ProgramVersion
	if pver == emptyString {
		pver = "0.0.1"
	}
	txt := "#\n# Generated by 7Q-Station-Manager\n#\n"
	return fmt.Sprintf(
		"%s\n<ADIF_VER:%d>%s\n<CREATED_TIMESTAMP:%d>%s\n<PROGRAMID:%d>%s\n<PROGRAMVERSION:%d>%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n",
		txt,
		len(ver),
		ver,
		len(ts),
		ts,
		len(pid),
		pid,
		len(pver),
		pver,
		UserDefQslWanted,
		UserDefFwdByEmailStatus,
		UserDefFwdByEmailDate,
		UserDefQsoUploadStatus,
		UserDefQsoUploadDate,
		EohStr,
	)
}

func (a *Adif) String() string {
	var buf bytes.Buffer
	buf.WriteString(a.HeaderSection.String())
	for _, record := range a.Records {
		buf.WriteString(record.String())
	}
	return buf.String()
}

func parseToAdifString(obj interface{}) string {
	var buf bytes.Buffer
	var parser func(v reflect.Value)

	parser = func(v reflect.Value) {
		for i := 0; i < v.NumField(); i++ {
			fieldName := v.Type().Field(i).Name
			if fieldName == "validate" {
				continue
			}

			field := v.Field(i)
			if field.Kind() == reflect.Ptr {
				field = field.Elem()
			}

			if field.Kind() == reflect.Struct {
				parser(field)
				continue
			}

			if field.Kind() == reflect.String && field.String() != emptyString {
				fieldTag := v.Type().Field(i).Tag
				// Prefer explicit ADIF mapping for adif module structs; fallback to json for embedded types
				tag := fieldTag.Get("adif")
				if tag == emptyString || tag == "-" {
					tag = fieldTag.Get(JsonStructTag)
				}
				tag = strings.TrimSuffix(tag, ",omitempty")
				if tag == emptyString || tag == "-" {
					continue
				}
				buf.WriteString(formatField(tag, field.String()))
			}
		}
	}

	parser(reflect.ValueOf(obj).Elem())
	buf.WriteString(EorStr)
	buf.WriteString(NewLineStr)

	return buf.String()
}

func formatField(tagName string, value string) string {
	tagName = strings.ToUpper(tagName)

	// Special formatting required for certain fields by the ADIF standard.
	switch tagName {
	case "FREQ", "FREQ_RX":
		//		value = normalizeFreqMHz(value)
		value = khzToMHz(value)
	case "QSO_DATE", "QSO_DATE_OFF", "QSLRDATE", "QSLSDATE":
		value = strings.ReplaceAll(value, DashStr, emptyString)
	case "TIME_ON", "TIME_OFF":
		value = strings.ReplaceAll(value, ColonStr, emptyString)
	}

	return fmt.Sprintf(elementFormat, tagName, len(value), value)
}

// normalizeFreqMHz attempts to normalize frequency strings to MHz with decimals.
// Examples:
//   - "7.050.000" -> "7.050"
//   - "144.390"   -> "144.390"
//   - "144."      -> "144"
//
// The function is defensive and will not panic on short inputs.
func normalizeFreqMHz(s string) string {
	s = strings.TrimSpace(s)
	if s == emptyString {
		return s
	}
	// If it contains two dots (xxx.xxx.xxx), drop the last group
	if strings.Count(s, ".") >= 2 {
		last := strings.LastIndex(s, ".")
		if last > 0 {
			s = s[:last]
		}
	}
	// Remove any trailing dot, e.g., "144." -> "144"
	s = strings.TrimSuffix(s, ".")

	return s
}

// khzToMHz converts a frequency string of 7 or 8 characters (representing kHz) to MHz.
// Example: "14310000" -> "14.310"
func khzToMHz(s string) string {
	if len(s) < 7 || len(s) > 8 {
		return s
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return s
	}
	// The input is assumed to be in a format where 14310000 represents 14.310 MHz.
	// This corresponds to dividing by 1,000,000.
	return fmt.Sprintf("%.3f", f/1000000.0)
}
